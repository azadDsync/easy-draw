// src/export/toSVG.ts
// Export canvas to SVG format
// Pure function - no side effects

import type { CanvasState } from "../canvas/types";

/**
 * SVG generation options
 */
interface SVGOptions {
  cellSize?: number; // Size of each cell in pixels
  strokeWidth?: number; // Border width
  strokeColor?: string; // Border color
  backgroundColor?: string; // Background color
  includeGrid?: boolean; // Show grid lines
}

/**
 * Default SVG options
 */
const DEFAULT_SVG_OPTIONS: Required<SVGOptions> = {
  cellSize: 20,
  strokeWidth: 1,
  strokeColor: "#cccccc",
  backgroundColor: "#ffffff",
  includeGrid: false,
};

/**
 * Escapes XML special characters
 */
function escapeXML(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

/**
 * Generates SVG rectangle for a cell
 */
function generateCellRect(
  row: number,
  col: number,
  color: string,
  cellSize: number,
  strokeWidth: number,
  strokeColor: string
): string {
  const x = col * cellSize;
  const y = row * cellSize;

  return `  <rect x="${x}" y="${y}" width="${cellSize}" height="${cellSize}" fill="${escapeXML(
    color
  )}" stroke="${escapeXML(strokeColor)}" stroke-width="${strokeWidth}"/>`;
}

/**
 * Generates grid lines
 */
function generateGrid(
  width: number,
  height: number,
  cellSize: number,
  strokeColor: string
): string[] {
  const lines: string[] = [];
  const svgWidth = width * cellSize;
  const svgHeight = height * cellSize;

  // Vertical lines
  for (let col = 0; col <= width; col++) {
    const x = col * cellSize;
    lines.push(
      `  <line x1="${x}" y1="0" x2="${x}" y2="${svgHeight}" stroke="${escapeXML(
        strokeColor
      )}" stroke-width="0.5"/>`
    );
  }

  // Horizontal lines
  for (let row = 0; row <= height; row++) {
    const y = row * cellSize;
    lines.push(
      `  <line x1="0" y1="${y}" x2="${svgWidth}" y2="${y}" stroke="${escapeXML(
        strokeColor
      )}" stroke-width="0.5"/>`
    );
  }

  return lines;
}

/**
 * Converts canvas to SVG string
 */
export function canvasToSVG(canvas: CanvasState, options: SVGOptions = {}): string {
  const opts = { ...DEFAULT_SVG_OPTIONS, ...options };

  const svgWidth = canvas.config.width * opts.cellSize;
  const svgHeight = canvas.config.height * opts.cellSize;

  const lines: string[] = [];

  // SVG header
  lines.push('<?xml version="1.0" encoding="UTF-8"?>');
  lines.push(
    `<svg xmlns="http://www.w3.org/2000/svg" width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}">`
  );

  // Background
  lines.push(
    `  <rect x="0" y="0" width="${svgWidth}" height="${svgHeight}" fill="${escapeXML(
      opts.backgroundColor
    )}"/>`
  );

  // Grid (if enabled)
  if (opts.includeGrid) {
    const gridLines = generateGrid(
      canvas.config.width,
      canvas.config.height,
      opts.cellSize,
      opts.strokeColor
    );
    lines.push(...gridLines);
  }

  // Painted cells
  // Sort cells deterministically by row then col
  const sortedCells = Array.from(canvas.cells.values()).sort((a, b) => {
    if (a.row !== b.row) return a.row - b.row;
    return a.col - b.col;
  });

  sortedCells.forEach((cell) => {
    const rect = generateCellRect(
      cell.row,
      cell.col,
      cell.color,
      opts.cellSize,
      opts.strokeWidth,
      opts.strokeColor
    );
    lines.push(rect);
  });

  // SVG footer
  lines.push("</svg>");

  return lines.join("\n");
}

/**
 * Generates SVG with metadata comment
 */
export function canvasToSVGWithMetadata(
  canvas: CanvasState,
  options: SVGOptions = {}
): string {
  const svg = canvasToSVG(canvas, options);
  const timestamp = new Date().toISOString();
  const metadata = [
    "<!--",
    `  Generated by Easy Draw`,
    `  Date: ${timestamp}`,
    `  Canvas: ${canvas.config.width}x${canvas.config.height}`,
    `  Painted cells: ${canvas.cells.size}`,
    "-->",
  ].join("\n");

  return metadata + "\n" + svg;
}

/**
 * Calculates optimal cell size for target dimensions
 */
export function calculateOptimalCellSize(
  canvas: CanvasState,
  targetWidth: number,
  targetHeight: number
): number {
  const cellSizeByWidth = Math.floor(targetWidth / canvas.config.width);
  const cellSizeByHeight = Math.floor(targetHeight / canvas.config.height);

  // Use smaller to fit within both dimensions
  return Math.min(cellSizeByWidth, cellSizeByHeight, 50); // Max 50px per cell
}
